<html>
 <head></head> 
 <body> 
  <p></p> 
  <p><strong>应用背景<br /></strong>海量数据的<a href="http://www.runqian.com.cn/rqrptcenter/12_rqrptct_2.htm">报表</a>在读取访问过程中可能会出现速度过慢、内存溢出、系统死机等问题，润乾目前提供的分页标签有两种标签：extHtml和aotuBig标签可以很好的支持报表的分页读取、展现及导出。此种方式在发布报表的时候需要用不同于html标签，需要在报表展现的页面上调用分页标签进行报表发布。<br />本文采用了oracle存储过程+普通报表模板的方式能够实现大数据量报表的分页读取，利用oracle存储过程实现分页，在报表模板中使用分页查询结果，报表发布页面仍然使用润乾html标签（普通报表发布页面，如润乾提供的showReport.jsp页面）。 该方式采用另一种思路实现了海量数据报表的分页访问，提升报表查询展现速度。</p> 
  <br /> 
  <p><strong>实现方案</strong></p> 
  <br /> 
  <p>1.测试数据建立：<br />利用如下sql在数据库中生成50万条测试数据<br />create table myTestTable as<br />select rownum as id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to_char(sysdate + rownum/24/3600, ‘yyyy-mm-dd hh24:mi:ss’) as inc_datetime,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trunc(dbms_random.value(0, 100)) as random_id,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbms_random.string(‘x’, 20) random_string<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from dual<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connect by level &lt;= 500000;</p> 
  <br /> 
  <p>&nbsp;</p> 
  <br /> 
  <p>2.建立数据库存储过程：<br />oracle中建立分页存储过程fenye<br />create or replace package testpackage as<br />&nbsp; TYPE test_cursor is ref cursor;<br />end testpackage;</p> 
  <br /> 
  <p>create or replace procedure fenye<br />(<br />&nbsp;&nbsp;&nbsp;&nbsp; p_cursor out testpackage.test_cursor,–返回的记录集<br />&nbsp;&nbsp;&nbsp;&nbsp; tableName in varchar2,–表名<br />&nbsp;&nbsp;&nbsp;&nbsp; Pagesize in number,–一页显示记录数<br />&nbsp;&nbsp;&nbsp;&nbsp; pageNow in number,–当前页<br />&nbsp;&nbsp;&nbsp;&nbsp; myrows out number,–总记录数<br />&nbsp;&nbsp;&nbsp;&nbsp; myPageCount out number–总页数<br />) is<br />–定义部分<br />–定义sql语句 字符串<br />v_sql varchar2(1000);<br />–定义两个整数<br />v_begin number:=(pageNow-1)*Pagesize+1;<br />v_end number:=pageNow*Pagesize;<br />begin<br />–执行部分<br />v_sql:=’select * from (select t1.*, rownum rn from (select * from ‘||tableName||’) t1 where rownum&lt;=’||v_end||’) where rn&gt;=’||v_begin;&nbsp;&nbsp; <br />–把游标和sql关联<br />open p_cursor for v_sql;<br />–计算myrows和myPageCount<br />–组织一个sql语句<br />v_sql:=’select count(*) from ‘||tableName;<br />–执行sql,并把返回的值，赋给myrows；<br />execute immediate v_sql into myrows;<br />–计算myPageCount<br />if mod(myrows,Pagesize)=0 then<br />&nbsp; myPageCount:=myrows/Pagesize;<br />else<br />&nbsp; myPageCount:=myrows/Pagesize+1;<br />end if;<br />end;</p> 
  <br /> 
  <p>3.报表模板开发<br />A.参数定义：<br />&nbsp;<img border="0" src="/wp-content/uploads/2011/07/c391bf4c-cd42-49c8-a3e7-934d05b68e42.jpg" /><br />B.数据集定义：<br />&nbsp;<img border="0" src="/wp-content/uploads/2011/07/b8dd6505-c002-425c-8f8b-ff816821d34f.jpg" /><img border="0" src="/wp-content/uploads/2011/07/a7fa2444-3b31-4e62-a62d-747b20176a76.jpg" /><br />&nbsp;<br />润乾报表可以使用存储过程作为数据集，一般情况下的输出参数类型均为“游标”类型，当然作为结果集返回一定 要使用游标类型。这里调用了分页存储过程fenye，查询结果返回为“游标”，传递给输出参数result。同时该存储过程还有3个输入参数，分别利用参数模板中定义的参数@p_table,@pageSize,@pageNo，输出参数除了有游标类型参数外还有非游标类型参数，参数返回结果分别传递给报表参数totalRows和PageCount。<br />C．单元格表达式：<br />&nbsp;<img border="0" src="/wp-content/uploads/2011/07/7df7a948-3693-43b0-9e6a-64173f0f035e.jpg" /><br />为实现报表翻页功能，在报表第一行模拟翻页功能条的效果。注意这里的分页和存储过程中的分页是有区别的。这里的分页可以理解为逻辑分页，存储过程的分页可以理解为物理分页。一个物理分页的结果可以再划分为多个逻辑分页结果。这里的页码是逻辑分页的页码。<br />A1：<br />值表达式：=”共”+@totalRows+”条”<br />该单元格调用输出参数@totalRows返回结果，完成表达式拼接，显示总记录数。<br />B1：<br />值表达式：=”共”+@pageCount+”页”<br />该单元格调用输出参数@pageCount返回结果，完成表达式拼接，显示总页数。<br />C1: <br />值表达式：=”当前第”+int((@pageNo-1)*int(@pageSize/10)+pno())+”页”<br />该单元格利用参数@pageNo，@pageSize和当前页函数pno()得到当前访问页码（逻辑分页页码）。<br />D1：<br />值：上一页<br />可视表达式：if(@pageNo&lt;=1,false,true) 如果当前物理分页小于等于1，不显示。<br />超链接表达式：=”/reportJsp/showReport.jsp?raq=pageProc.raq&amp;pageNo=”+int(@pageNo-1)+”&amp;pageSize=50″<br />刷新页面，存储过程查询上一个物理分页结果，返回给报表。（注意这里的存储过程分页大小（物理分页）为50）<br />F1：<br />值：上一页<br />可视表达式：if(@pageNo&gt;=@pageCount,false,true) 如果当前物理分页大于等于总物理分页数，不显示。<br />超链接表达式：<br />=”/reportJsp/showReport.jsp?raq=pageProc.raq&amp;pageNo=”+int(@pageNo+1)+”&amp;pageSize=50″<br />刷新页面，存储过程查询下一个物理分页结果，返回给报表。（注意这里的存储过程分页大小（物理分页）为50）<br />E1： <br />值表达式：=to(1,@pageSize/10) 横向扩展，表示一个物理分页被分为了@pageSize/10个逻辑分页。<br />显示值表达式：=value()+(@pageNo-1)*int(@pageSize/10) 计算逻辑分页值<br />超链接表达式：=”javascript:report1_toPage(“+value()+”)”&nbsp; 调用内置功能函数完成指定页面跳转<br />4.效果展现：<br />&nbsp;<img border="0" src="/wp-content/uploads/2011/07/efcf8a47-6b04-4741-a4df-f568dcbe6581.jpg" /><img border="0" src="/wp-content/uploads/2011/07/5da0a1f0-92a3-4976-ab56-1f3dc4e59fa2.jpg" /><br />&nbsp;<br /><strong>性能对比</strong><strong><br /></strong>1).基于本文建立的测试数据表myTestTable（数据量20万），建立普通网格式报表。报表访问控制台打印信息如下，共用11秒。<br />&nbsp;<img border="0" src="/wp-content/uploads/2011/07/e5ee8156-a4be-4846-a429-f11b490dcae6.jpg" /><br />如果测试数据上升至50万，报内存溢出错误，控制台输出信息如下：<br />&nbsp;<img border="0" src="/wp-content/uploads/2011/07/31ad0b70-54a3-4282-84f5-944710fb71d7.jpg" /><br />2).基于本文建立的测试数据表myTestTable（数据量20万），建立行式报表。报表访问控制台打印信息如下，共用8秒。</p> 
  <br /> 
  <p><img border="0" src="/wp-content/uploads/2011/07/5229e84d-f85a-4b5d-8826-75f87ec07411.jpg" /><br />如果测试数据上升至50万，报表展现速度缓慢，控制台输出信息如下，共用51秒。<br />&nbsp;<img border="0" src="/wp-content/uploads/2011/07/6c640f04-4aea-4280-be2e-d8a109a85755.jpg" /><br />3)用分页存储过程的方式，无论数据量是20万还是50万，报表访问展现速度都不会受到多大的影响，均能在1,2秒内完成报表展现。每次点击下一页的时候会根据参数调用存储过程进行数据查询。<br /><strong>&nbsp;<img border="0" src="/wp-content/uploads/2011/07/ffbe9a3e-abf5-42ce-a31a-64b588f1eb97.jpg" /><br />小结<br /></strong>本文采用数据库存储过程+普通报表的方式，用普通html标签就可以完成大数据量报表的分页查询展现，不使用润乾提供的分页标签（extHtml和aotuBig标签）同样能实现大数据量报表的分页展现，提升报表展现速度。</p> 
  <br /> 
  <p></p>  
 </body>
</html>